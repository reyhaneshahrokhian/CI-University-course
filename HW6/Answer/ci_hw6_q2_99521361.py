# -*- coding: utf-8 -*-
"""CI_HW6_Q2_99521361.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19aEfOJGBotz6kl6CL0-xuFvRzJegEcRk
"""

import numpy as np

# Define equations with names
equations = [
    {"name": "Equation 1", "equation": lambda x: 2*x - 4},
    {"name": "Equation 2", "equation": lambda x: x**2 - 8*x + 4},
    {"name": "Equation 3", "equation": lambda x: 4*(x**3) - 5*(x**2) + x - 1},
    {"name": "Equation 4", "equation": lambda x: 186*(x**3) - 7.22*(x**2) + 15.5*x - 13.2}
]

def fitness(candidate, equation_func):
    return 1 / (1 + np.abs(equation_func(candidate)))

def initialize_population(population_size, search_range):
    return np.random.uniform(search_range[0], search_range[1], population_size)

def select_parents(population, fitness_scores):
    probabilities = fitness_scores / np.sum(fitness_scores)
    parents_indices = np.random.choice(len(population), size=2, p=probabilities)
    return population[parents_indices]

def arithmetic_crossover(parents):
    alpha = np.random.rand()  # Weighting factor
    return alpha * parents[0] + (1 - alpha) * parents[1]

def mutate(child, mutation_rate, mutation_range):
    if np.random.rand() < mutation_rate:
        return child + np.random.uniform(mutation_range[0], mutation_range[1])
    else:
        return child

def genetic_algorithm(equation, population_size=100, generations=1000, search_range=(-10, 10), mutation_rate=0.1, mutation_range=(-0.1, 0.1)):
    population = initialize_population(population_size, search_range)

    for generation in range(generations):
        fitness_scores = np.array([fitness(candidate, equation["equation"]) for candidate in population])

        parents = [select_parents(population, fitness_scores) for _ in range(population_size // 2)]
        children = [arithmetic_crossover(parents) for parents in parents]
        population = np.array([mutate(child, mutation_rate, mutation_range) for child in children])

    best_solution = population[np.argmax(fitness_scores)]
    return best_solution

# Solve equations
for equation_info in equations:
    root = genetic_algorithm(equation_info, generations=1000)
    print(f"{equation_info['name']}, Root: {root}")

